/*
 * Audio Feature Extractor Implementation
 * =====================================
 */

#include "feature_extractor.h"

// Include normalization parameters (will be generated by conversion script)
extern const float FEATURE_MEAN[];
extern const float FEATURE_STD[];

FeatureExtractor::FeatureExtractor() {
    // Initialize pointers
    fft_input = nullptr;
    fft_output = nullptr;
    power_spectrum = nullptr;
    mel_filters = nullptr;
    filter_starts = nullptr;
    filter_ends = nullptr;
    window_function = nullptr;
    mel_spectrogram = nullptr;
    feature_mean = nullptr;
    feature_std = nullptr;
    
    // Set parameters
    hop_samples = HOP_LENGTH;
    frame_samples = FRAME_LENGTH;
    
    // Clear stats
    memset(&last_stats, 0, sizeof(last_stats));
}

FeatureExtractor::~FeatureExtractor() {
    // Free FFT buffers
    if (fft_input) free(fft_input);
    if (fft_output) free(fft_output);
    if (power_spectrum) free(power_spectrum);
    
    // Free mel filter bank
    if (mel_filters) {
        for (int i = 0; i < N_MEL_BANDS; i++) {
            if (mel_filters[i]) free(mel_filters[i]);
        }
        free(mel_filters);
    }
    if (filter_starts) free(filter_starts);
    if (filter_ends) free(filter_ends);
    
    // Free other buffers
    if (window_function) free(window_function);
    if (mel_spectrogram) free(mel_spectrogram);
    if (feature_mean) free(feature_mean);
    if (feature_std) free(feature_std);
}

bool FeatureExtractor::init() {
    DEBUG_INFO("Initializing Feature Extractor...\n");
    
    // Allocate FFT buffers (use PSRAM for large buffers)
    fft_input = (double*)ps_malloc(N_FFT * sizeof(double));
    fft_output = (double*)ps_malloc(N_FFT * sizeof(double));
    power_spectrum = (float*)ps_malloc((N_FFT / 2 + 1) * sizeof(float));
    
    if (!fft_input || !fft_output || !power_spectrum) {
        DEBUG_ERROR("Failed to allocate FFT buffers\n");
        return false;
    }
    
    // Allocate mel filter bank
    mel_filters = (float**)malloc(N_MEL_BANDS * sizeof(float*));
    filter_starts = (int*)malloc(N_MEL_BANDS * sizeof(int));
    filter_ends = (int*)malloc(N_MEL_BANDS * sizeof(int));
    
    if (!mel_filters || !filter_starts || !filter_ends) {
        DEBUG_ERROR("Failed to allocate mel filter arrays\n");
        return false;
    }
    
    for (int i = 0; i < N_MEL_BANDS; i++) {
        mel_filters[i] = (float*)malloc((N_FFT / 2 + 1) * sizeof(float));
        if (!mel_filters[i]) {
            DEBUG_ERROR("Failed to allocate mel filter %d\n", i);
            return false;
        }
    }
    
    // Allocate window function
    window_function = (float*)malloc(frame_samples * sizeof(float));
    if (!window_function) {
        DEBUG_ERROR("Failed to allocate window function\n");
        return false;
    }
    
    // Allocate output buffer
    mel_spectrogram = (float*)ps_malloc(N_TIME_FRAMES * N_MEL_BANDS * sizeof(float));
    if (!mel_spectrogram) {
        DEBUG_ERROR("Failed to allocate mel spectrogram buffer\n");
        return false;
    }
    
    // Allocate normalization parameter buffers
    feature_mean = (float*)malloc(N_MEL_BANDS * sizeof(float));
    feature_std = (float*)malloc(N_MEL_BANDS * sizeof(float));
    
    if (!feature_mean || !feature_std) {
        DEBUG_ERROR("Failed to allocate normalization buffers\n");
        return false;
    }
    
    // Initialize FFT
    fft = arduinoFFT(fft_input, fft_output, N_FFT, SAMPLE_RATE);
    
    // Compute window function (Hamming window)
    for (int i = 0; i < frame_samples; i++) {
        window_function[i] = 0.54f - 0.46f * cosf(2.0f * PI * i / (frame_samples - 1));
    }
    
    // Compute mel filter bank
    compute_mel_filters();
    
    // Load normalization parameters
    if (!load_normalization_params()) {
        DEBUG_WARN("Failed to load normalization parameters, using defaults\n");
        // Set default parameters (zeros and ones)
        for (int i = 0; i < N_MEL_BANDS; i++) {
            feature_mean[i] = 0.0f;
            feature_std[i] = 1.0f;
        }
    }
    
    DEBUG_INFO("Feature Extractor initialized successfully\n");
    DEBUG_INFO("  FFT size: %d\n", N_FFT);
    DEBUG_INFO("  Mel bands: %d\n", N_MEL_BANDS);
    DEBUG_INFO("  Time frames: %d\n", N_TIME_FRAMES);
    DEBUG_INFO("  Hop length: %d samples (%.1f ms)\n", hop_samples, (float)hop_samples * 1000 / SAMPLE_RATE);
    
    return true;
}

bool FeatureExtractor::extract_features(float* audio, int audio_length, float* output_features) {
    TIMING_START();
    memset(&last_stats, 0, sizeof(last_stats));
    
    if (audio_length < SAMPLES_PER_WINDOW) {
        DEBUG_ERROR("Audio length %d < required %d samples\n", audio_length, (int)SAMPLES_PER_WINDOW);
        return false;
    }
    
    // Extract frames and compute mel spectrogram
    int frame_count = 0;
    
    for (int frame_start = 0; frame_start + frame_samples <= audio_length && frame_count < N_TIME_FRAMES; 
         frame_start += hop_samples, frame_count++) {
        
        unsigned long fft_start = micros();
        
        // Apply window and copy to FFT input
        for (int i = 0; i < frame_samples; i++) {
            fft_input[i] = audio[frame_start + i] * window_function[i];
        }
        
        // Zero pad
        for (int i = frame_samples; i < N_FFT; i++) {
            fft_input[i] = 0.0;
        }
        
        // Compute FFT
        fft.Windowing(FFT_WIN_TYP_RECTANGLE, FFT_FORWARD);  // Window already applied
        fft.Compute(FFT_FORWARD);
        fft.ComplexToMagnitude();
        
        // Compute power spectrum
        compute_power_spectrum();
        
        last_stats.fft_time_us += micros() - fft_start;
        
        // Apply mel filters
        unsigned long mel_start = micros();
        apply_mel_filters(frame_count);
        last_stats.mel_time_us += micros() - mel_start;
    }
    
    last_stats.n_frames_processed = frame_count;
    
    // Pad remaining frames with zeros if needed
    for (int frame = frame_count; frame < N_TIME_FRAMES; frame++) {
        for (int band = 0; band < N_MEL_BANDS; band++) {
            mel_spectrogram[frame * N_MEL_BANDS + band] = -10.0f;  // Log of small value
        }
    }
    
    // Apply normalization
    unsigned long norm_start = micros();
    for (int i = 0; i < N_TIME_FRAMES * N_MEL_BANDS; i++) {
        int band = i % N_MEL_BANDS;
        output_features[i] = (mel_spectrogram[i] - feature_mean[band]) / feature_std[band];
    }
    last_stats.norm_time_us = micros() - norm_start;
    
    last_stats.total_time_us = micros() - start_time;
    
    DEBUG_DEBUG("Feature extraction: %lu us (FFT: %lu, Mel: %lu, Norm: %lu, Frames: %d)\n",
                last_stats.total_time_us, last_stats.fft_time_us, 
                last_stats.mel_time_us, last_stats.norm_time_us, frame_count);
    
    return true;
}

void FeatureExtractor::compute_mel_filters() {
    DEBUG_INFO("Computing mel filter bank...\n");
    
    // Mel scale parameters
    float mel_low = hz_to_mel(0);
    float mel_high = hz_to_mel(SAMPLE_RATE / 2);
    
    // Create mel-spaced frequency points
    float* mel_points = (float*)malloc((N_MEL_BANDS + 2) * sizeof(float));
    for (int i = 0; i < N_MEL_BANDS + 2; i++) {
        mel_points[i] = mel_low + (mel_high - mel_low) * i / (N_MEL_BANDS + 1);
    }
    
    // Convert back to Hz
    float* hz_points = (float*)malloc((N_MEL_BANDS + 2) * sizeof(float));
    for (int i = 0; i < N_MEL_BANDS + 2; i++) {
        hz_points[i] = mel_to_hz(mel_points[i]);
    }
    
    // Convert Hz to FFT bin numbers
    int* bin_points = (int*)malloc((N_MEL_BANDS + 2) * sizeof(int));
    for (int i = 0; i < N_MEL_BANDS + 2; i++) {
        bin_points[i] = (int)floorf(hz_points[i] * N_FFT / SAMPLE_RATE);
    }
    
    // Create triangular filters
    int n_fft_bins = N_FFT / 2 + 1;
    
    for (int m = 0; m < N_MEL_BANDS; m++) {
        int left = bin_points[m];
        int center = bin_points[m + 1];
        int right = bin_points[m + 2];
        
        filter_starts[m] = left;
        filter_ends[m] = right;
        
        // Initialize filter
        for (int k = 0; k < n_fft_bins; k++) {
            mel_filters[m][k] = 0.0f;
        }
        
        // Left side of triangle
        for (int k = left; k < center; k++) {
            if (center > left) {
                mel_filters[m][k] = (float)(k - left) / (center - left);
            }
        }
        
        // Right side of triangle
        for (int k = center; k < right; k++) {
            if (right > center) {
                mel_filters[m][k] = (float)(right - k) / (right - center);
            }
        }
    }
    
    free(mel_points);
    free(hz_points);
    free(bin_points);
    
    DEBUG_INFO("Mel filter bank computed (%d filters)\n", N_MEL_BANDS);
}

float FeatureExtractor::hz_to_mel(float hz) {
    return 2595.0f * log10f(1.0f + hz / 700.0f);
}

float FeatureExtractor::mel_to_hz(float mel) {
    return 700.0f * (powf(10.0f, mel / 2595.0f) - 1.0f);
}

void FeatureExtractor::compute_power_spectrum() {
    int n_fft_bins = N_FFT / 2 + 1;
    
    for (int i = 0; i < n_fft_bins; i++) {
        power_spectrum[i] = fft_output[i] * fft_output[i];
    }
}

void FeatureExtractor::apply_mel_filters(int frame_idx) {
    int n_fft_bins = N_FFT / 2 + 1;
    
    for (int m = 0; m < N_MEL_BANDS; m++) {
        float mel_energy = 0.0f;
        
        // Apply triangular filter
        for (int k = filter_starts[m]; k < filter_ends[m] && k < n_fft_bins; k++) {
            mel_energy += power_spectrum[k] * mel_filters[m][k];
        }
        
        // Convert to log scale (with small epsilon to avoid log(0))
        mel_energy = logf(mel_energy + 1e-8f);
        
        // Store in mel spectrogram
        mel_spectrogram[frame_idx * N_MEL_BANDS + m] = mel_energy;
    }
}

bool FeatureExtractor::load_normalization_params() {
    // In a real implementation, this would load from SPIFFS or embedded data
    // For now, we'll copy from the extern arrays (included from generated header)
    
    try {
        for (int i = 0; i < N_MEL_BANDS; i++) {
            feature_mean[i] = FEATURE_MEAN[i];
            feature_std[i] = FEATURE_STD[i];
        }
        
        DEBUG_INFO("Normalization parameters loaded\n");
        DEBUG_DEBUG("  Mean range: [%.6f, %.6f]\n", 
                   feature_mean[0], feature_mean[N_MEL_BANDS-1]);
        DEBUG_DEBUG("  Std range: [%.6f, %.6f]\n", 
                   feature_std[0], feature_std[N_MEL_BANDS-1]);
        
        return true;
    } catch (...) {
        DEBUG_ERROR("Failed to load normalization parameters\n");
        return false;
    }
}